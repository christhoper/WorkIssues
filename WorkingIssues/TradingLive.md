#Fastbull.live

一、项目亮点、难点

- 1、组件化之间跨模块的传值优化处理：
* 产生原因：随着项目功能模块越来越多，之前独立的模块开始需要与其他模块通信，每个功能模块所需要的参数形形色色，所以导致了每个模块之间的通信传值混乱难以维护；
* 处理：采用中介者设计模式，将模块间通信交互逻辑剥离到中介者。
* 效果：通过中介者作为模块之间的通信媒介，模块之间的通信极大变得简化，优化了代码结构，使代码变得更容易维护。

- 2、视频详情滑动优化：
* 产生原因：视频详情里有许多不同类型的数据，比如直播、预约、视频；但是经排查是由于视频类型的cell同时持有tableView，playerController，以及videoControl导致的问题。因为持有tableView和在滑动的时候从外部创建一个playerController，然后赋值给cell，将播放的逻辑都放在了cell里面去，当滑动时就在不断创建赋值播放器，所以导致了滑动时的不流畅，职责也不分明，代码耦合严重。
* 处理：对视频详情这块功能代码进行了重构；首先用一个playerManager管理播放器的播放逻辑，比如获取封面，是否缓冲中，播放进行中，播放结束，播放错误等；再用playerView对视频控制层进行管理，点击播放、拖动进度，横竖屏等操作控制，使之他们的职责相互独立，从而达到解耦目的；其次为了滑动的顺畅性，以牺牲内存空间来换取更好的用户体验。在视频详情控制器里用一个队列维护了三个播放器，当前播放的视频则设置为中间播放器，如果上下滑动时，则会从队列里取出缓存好的播放器，并将当前播放器重置，然后回收到队列中等待使用。（其实可以用三个控制器来处理，代码分离的更好）
* 效果：通过这种方式，滑动视频时不再会感到有卡顿现象

- 3、lottie加载json动画占用CPU过高的优化处理：
* 产生原因：项目中直播标识，关注用户、点赞等动效，都使用了lottie加载json文件来实现效果，但是经查看CPU占用情况发现，lottie实现动效的时候，CPU高了差不多20%，（原因：⚠️⚠️⚠️）后换成使用apng动效的方式代替，cpu得已下降
* 处理：将json动画换成APNG动画
* 效果：手机的cpu下降差不多20%

- 4、阿拉伯语言的适配：
* 产生原因：因阿拉伯人操作的习惯不一样，项目需要对阿拉伯语进行适配。
* 处理：采用swizzling方法，将系统方法和自定义的方法进行exchange，只不过swift没有+load方法，所以需要在main文件里调用一下。对于有的按钮图片，还需要做图片镜像翻转（具体翻转做法：先判断是否是阿拉伯语，如果是则根据原图基础上创建一个CGRect矩阵，然后创建基于位图的图形上下文context，通过获取当前绘图的环境（currentContext），将其绘制到上面创建的矩阵中，再将当前绘图环境旋转180度，再对原来图片进行x（图片宽）y（图片高度）的平移，再调用draw进行绘制，最后获得镜像翻转后的图片）
* 效果：运用swizzling技术，极大的减轻了适配工作。

- 5、视频上传的优化：
* 产生原因：上传逻辑基于Alamofire，之前并没有做对单个上传任务取消功能，也没有做断点续传功能，每次取消某个任务的时候都会全部取消了；
* 处理：经过阅读Alamofire上传代码发现，Alamofire是可以对某个具体的任务进行取消操作，里面提供的取消全部请求（Requests），也是对所有的请求进行遍历，然后执行cancel操作。所以上传的时候只需能查找到对应上传的请求（request），执行cancel操作即可；关于断点续传处理，是将整个视频进行了分片，比如将视频分成了10片，再将分好的片段上传到服务器，服务器那边进行合成操作；对于在某种情况下导致的分片上传失败情况，直接重新上传失败的分片即可。
* 效果：1、因为采取了分片方法，极大加快了视频上传的进度；2、优化了用户体验，节省了用户流量

- 6、组件化跨模块之间代码的优化处理：
* 产生原因：代码基于模版创建，下个页面回调上个页面是基于OuterSide协议，但是当跨模块时，就需要层层回调或者使用通知处理，极大不方便代码维护
* 处理：在router创建的控制器的api中，使用block作为参数，注入到下一个页面中使用
