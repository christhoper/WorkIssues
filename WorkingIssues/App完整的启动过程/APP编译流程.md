## 编译成APP过程

### 解释器、编译器相关：
* 解释器：运行时才会去解释执行代码，获取一段代码后就会将其翻译成目标代码( [ByteCode](字节码))，然后一句一句的去执行目标代码；
* 编译器：把代码编译成机器码，然后直接在CPU上执行机器码。
* 优缺点： 解释器调试方便，但执行效率低（Phythod，shell，Perl等）；编译器执行效率高，但调试周期长（Objective—C，C，C++，Swift）

### 1、预编译：
对每个文件的头文件进行展开、宏定义的替换等操作;

### 2、编译:
* 前端：
①：词法分析：主要是生成一个一个的 [](token)
②：语法分析：生成抽象语法树，简称 [](AST)，生成中间代码IR

* 中间代码：
生成 [](.ll) 后缀的文件，作为后端的输入，并且由优化器做相应等级优化

* 后端
①：[](.ll) 转化为汇编 .s
②：[](.s) 文件转化为一个个 [](.o) 的可执行文件
③：生成一个macho的可执行文件 (如何生成)


### 3、链接  (通过dyld)
①：调用 [](exex())  程序函数入口，开启进程空间；
②：加载编译好的 [](macho) 文件
③：[](dyld) 链接器进行链接
④：[](dyld) 从共享缓存空间递归加载依赖库，比如 [](libsystem)，[](libdispatch)，[](libobjc)，[](Foundation)框架等系统动态库（使用[](imagelist)命令可以查看到按顺序加载进的image镜像）
⑤：[](rebase) 操作，由于 [](alsr) 的原因，对 [](macho) 的 [](DATA)段的数据进行重定向
⑥：[](binding) 操作，对于调用的外部符号，进行绑定操作：
- [](dyld_stub_binder) 和 [](objc_msgSend) 符号进行绑定，属于非懒加载符号；
- 比如 print符号在Foundation库中，在第一次调用到的时候，会通过 dyld_stub_binder进行一个地址的绑定操作获取到真实的符号地址进行加载 ；
⑦：Objc Setup 操作，注册类到全局表中， [](category)加载，保证 [](sel) 唯一性修复验证等.
⑧：加载load方法，C++构造函数，静态变量初始化等
⑨：调用 main 函数， RunLoop 跑起项目启动。


### 4、链接解决的问题：
* 链接器在链接多个目标文件的过程中，会创建一个全局符号表，用来记录所有已定义的和所有未定义的符号；链接过程如果出现相同符号的情况，就会出现 “ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误;


### 5、链接器做了哪几件事
①：去项目文件里查找目标代码文件里没有定义的变量；
②：扫描项目中的不同文件，将所有符号定义和引用地址收集起来，并放到全局符号列表中；
③：计算合并后长度及位置，生成同类型的段进行合并，建立绑定；
④：对项目中不同文件里的变量进行地址重定位。

### 6、编译器如何清理没被调用的函数
链接器在整理函数的调用关系时，会以 [](main) 函数为源头，跟随每个引用，并将其标记为 [](live)，跟随完成后，那些未被标记为 [](live) 的函数，就是无用的函数。然后链接器可以通过打开 Dead Code Sptripping开关，来开启自动去除无用代码的功能。这个开关是默认开启的。
